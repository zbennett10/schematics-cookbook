# Recipe 1 - Altering Angular CLI's `ng generate component`

In this recipe, we will create a schematic that adds functionality to Angular CLI's `ng generate component` command. Under the hood, Angular CLI's `ng generate component` command uses a Angular schematic named `component`. To view this schematic's source code, visit [here](https://github.com/angular/angular-cli/tree/master/packages/schematics/angular/component).

To complete this recipe, you will need to have the Angular CLI installed on your host machine. To install Angular CLI globally on your machine, run the following command:

`npm install -g @angular/cli`

---

## Preparation

### Our Test Angular Application

First, we will create a new Angular project that will use the schematic we will soon create.

In order to create a new Angular application, we need to run the following command:

`ng new test-app`

You now have a new, baseline Angular application available in the `test-app` directory.

### Our Schematic Collection

Next, we are going to create the schematic collection that will house each one of our recipes. We will call it the `cookbook`.

In the same directory that houses our '`test-app`' Angular application, run the following command:

`schematics blank --name=cookbook`

That command scaffolded the Angular schematic collection which we will use to house all of our 'recipe' schematics.

We will need to update a couple of these dependencies. Run the following commands in order to update these two packages:

```bash
npm install --save @angular-devkit/core@latest

npm install --save @angular-devkit/schematics@latest
```

There is only one, further dependency which we will need in order to implement our recipes. The package `@schematics/angular` will enable us to use some of Angular's own schematics. These are schematics which the Angular CLI uses in order to scaffold out code. We need this package in our own schematics collection in order to use some of Angular's own schematics including it's `component` and `ng-new` schematics.

In order to install this NPM package run the following command in the root directory of our schematics collection:

`npm install --save @schematics/angular@latest`

### Creating Our First Recipe

First things first, we need to change the name of the `cookbook` schematic which was auto-generated inside of our `cookbook` schematic collection when we first created it. 

First off, we need to change this default schematic's metadata located inside of `cookbook/src/collection.json`.

We are going to change this schematic's name from `cookbook` to `cookbook-component`. Let's start by altering the `collection.json`. Here is an example of what our `collection.json` will look like after these alterations:

```json
{
    "$schema": "../node_modules/@angular-devkit/schematics/collection-schema.json",
    "schematics": {
        "cookbook-component": {
        "description": "Generates a cookbook Angular component",
        "factory": "./cookbook-component/index#cookbookComponent"
        }
    }
}
```

Next, let's go ahead and rename our `cookbook-component` schematic directory from `cookbook/src/cookbook` to `cookbook/src/cookbook-component`.

After this, we need to make some changes to our schematic's RuleFactory located in `cookbook/src/cookbook-component/index.ts`. All that we will need to change is the name of our RuleFactory. Here is an example of what our schematic's RuleFactory will look like after these changes:

```javascript
import { Rule, SchematicContext, Tree } from '@angular-devkit/schematics';


// You don't have to export the function as default. You can also have more than one rule factory
// per file.
export function cookbookComponent(_options: any): Rule {
    return (tree: Tree, _context: SchematicContext) => {
        return tree;
    };
}
```

Next, we need to change our `cookbook-component` schematic's test file located at `cookbook/src/cookbook-component/index_spec.ts`. Here is what we want it to look like:

```javascript
import { Tree } from '@angular-devkit/schematics';
import { SchematicTestRunner } from '@angular-devkit/schematics/testing';
import * as path from 'path';


const collectionPath = path.join(__dirname, '../collection.json');


describe('cookbook-component schematic', () => {
  it('works', () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = runner.runSchematic('cookbook-component', {}, Tree.empty());

    expect(tree.files).toEqual([]);
  });
});
```

Next we need to prepare our template directory structure. We will do this by creating a directory named `files` in our schematic's directory. We need to create this directory at the following path: `cookbook/src/cookbook-component/files`.
This directory will house the templates for files that our schematic will create when invoked. This directory will house one file template with the filename `__name@dasherize__.service.ts`. This templated service file should look like this:

```javascript
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class <%= classify(name) %>Service {

  constructor() { }
}
```


Lastly, we need to create our schematic's schema file. We will create the file located at this path: `cookbook/src/cookbook-component/schema.json`.


## Cookbook-Component Implementation

With our preparation taken care of, it's time to implement the core logic of our schematic. We want our new schematic to augment Angular's existing `component` schematic through which users of the Angular CLI can scaffold out new Angular components through the command `ng generate component`. To make this happen, we will we will need to complete two tasks. Firstly, we need to call the external, `component` schematic that Angular provides. Secondly, we need to chain this schematic with our own functionality that augments the existing `component` schematic by adding an optional flag which will allow for a side-car service to be created alongside this component. When this flag is specified, our schematic will create a `<component-name>.service.ts` file alongside the `<component-name>.component.ts` file previously created by the external, `component` schematic.

### Step One - Schema Creation

The first part of creating our cookbook component schematic will be to create a schema for our schematic. For more information on schemas - please see the "Schematic Metadata and Validation" section of the "Schematics Overview" page earlier in this book.

We will want our simple, component schematic to take in a required `name` argument and an optional `service` argument. Here's what our schema looks like:

```json
{
    "$schema": "http://json-schema.org/schema",
    "id": "CookbookComponent",
    "title": "Cookbook Component",
    "type": "object",
    "properties": {
      "name": {
        "type": "string",
        "description": "Component name",
        "$default": {
          "$source": "argv",
          "index": 0
        }
      },
      "service": {
        "description": "Does this component need a side-car service?",
        "type": "boolean",
        "default": false,
        "alias": "s"
      }
    },
    "required": [
      "name"
    ]
  }
  

```

With our `schema.json` file successfully created, let's create its functional counterpart - the `schema.d.ts` file. This TypeScript-centric file's (It is aptly-named a declaration file - hence the `.d.`) sole purpose is to provide a usable TypeScript type definition that we can use within a Schematic's RuleFactory. This will give us some added type safety within our RuleFactory's code - allowing us to further validate the options which are passed in to our schematic. We want to create the `schema.d.ts` file within our `cookbook-component` schematic directory. We can easily create our `schema.d.ts` declaration file schema interface by looking at our schematic's `schema.json` file. Here is what our `schema.d.ts` file should look like:

```javascript
import { Schema as ComponentOptions} from '@schematics/angular/component/schema';

export interface Schema extends ComponentOptions {
    name: string,
    service?: boolean
}
```
In the above code we have simply created a `Schema` interface which is modeled after our `cookbook-component` schematic's `schema.json` which says that this schematic will expect a required `name` argument along with an optional `service` argument. We have also created this `Schema` interface to extend Angular's actual `component` schematic which is used by the Angular CLI in order to scaffold a new Angular component. Now all of the schematic options which are available to the `component` schematic will also be available to the `cookbook-component` schematic.

Now that we have successfully modeled our `cookbook-component` schematic's available options, let's write some tests!

### Step Two - Writing Unit Tests

In this section we will practice a little TDD (Test-Driven Development) by writing our schematic's unit tests before its RuleFactory logic.

First things first, we need to import our recently created `cookbook-component` schema into the `index_spec.ts` file.

```javascript
import { Schema as CookbookComponentOptions } from './schema';
```
Here we are simply importing our Schema and giving it the alias of `CookbookComponentOptions` in order to more accurately convey its functional purpose within the logic of our unit tests.

Now we are ready to write our first unit test. Let's just dive into the code and explain afterwards!

```javascript
import { Tree } from '@angular-devkit/schematics';
import { SchematicTestRunner } from '@angular-devkit/schematics/testing';
import * as path from 'path';

import { Schema as CookbookComponentOptions } from './schema';

const collectionPath = path.join(__dirname, '../collection.json');


describe('cookbook-component schematic', () => {
  it('creates a <comp-name>.service.ts file when the service option is given', () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const options: CookbookComponentOptions = {
      name: 'test-app-name',
      service: true
    };

    const tree = runner.runSchematic('cookbook-component', options, Tree.empty());

    expect(tree.files.indexOf(`/${options.name}/${options.name}.service.ts`)).toBeGreaterThan(-1);
  });

  it('doesn\'t create a <comp-name>.service.ts file when the service option is not given', () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const options: CookbookComponentOptions = { name: 'test-app-name' };

    const tree = runner.runSchematic('cookbook-component', options, Tree.empty());

    expect(options.service).toBeFalsy();
    expect(tree.files.indexOf(`/${options.name}/${options.name}.service.ts`)).toBe(-1);
  });
});

```

In the above test file we have created two unit units. The first unit test runs the `cookbook-component` schematic using the provided `SchematicTestRunner` class and then asserts that a service file is created in the `Tree` when the `service` flag is set to `true`. The second unit test simply tests the opposite condition. 

*Note:* By running `npm run test` inside of the project root, you should see one test pass and one test fail.


### Step Three - Implementing our Schematic's RuleFactory

Now it's time to code the logic of the `cookbook-component` schematic's `RuleFactory`. Let's jump in!

```javascript

```
-- do logic of index.ts -> call `component` schematic (external) -> add our own functionality to it (opt service)
-- go over steps to test in fake angular project (npm build and npm link then cd target angular app and npm link (collection-name-here) then ng g collection-name:schematics-name --blah --blah)
-- (test these steps one by one on host system and run through everything) 
